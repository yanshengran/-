# 关于KMP

参考自https://blog.csdn.net/yyzsir/article/details/89462339

KMP算法是对传统BF算法的优化，使源字符串上的指针不必回溯，时间复杂度为O(n+m)，KMP算法的核心是next数组的求解。

next数组中第i个元素的含义是：除了当前字符外前i-1个字符构成的字符串的最长公共前后缀长度。习惯上将next数组的第一个元素设为-1。

求解next数组：

已知next[ 0 ] = -1，next[ 1 ] = 0，接下来，假设next[ j ] = k，我们来求next[ j+1 ]：

分两种情况讨论（推导从略）：

* 若P[ k ] == P[ j ]：next[ j+1 ] = next[ j ]+1 = k + 1（注！代码中不要忘记更新k）
* 若P[ k ] != P[ j ]：在P[ 0 ]~P[ k ]中不断递归索引，令 k = next[ k ]，如果找到一个字符P[ k' ]也是P[ j ]则最大公共前后缀长度为k' + 1，即P[ j+1 ] = k' + 1，若k == -1则令P[ j+1 ] = 0。 